<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0-internal) on Fri Sep 26 11:44:16 EDT 2003 -->
<TITLE>
ReentrantLock.ConditionObject
</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.ReentrantLock.ConditionObject class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ReentrantLock.ConditionObject";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="class in java.util.concurrent.locks"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="class in java.util.concurrent.locks"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ReentrantLock.ConditionObject.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
Class ReentrantLock.ConditionObject</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../resources/inherit.gif" ALT="extended by"><B>java.util.concurrent.locks.ReentrantLock.ConditionObject</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A>, java.io.Serializable</DD>
</DL>
<DL>
<DT><B>Enclosing class:</B><DD><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="class in java.util.concurrent.locks">ReentrantLock</A></DD>
</DL>
<HR>
<DL>
<DT>public static class <B>ReentrantLock.ConditionObject</B><DT>extends java.lang.Object<DT>implements <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A>, java.io.Serializable</DL>

<P>
Condition implementation for use with <tt>ReentrantLock</tt>.
 Instances of this class can be constructed only using method
 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition()"><CODE>ReentrantLock.newCondition()</CODE></A>.
 
 <p>This class supports the same basic semantics and styles of
 usage as the <CODE>Object</CODE> monitor methods.  Methods may be
 invoked only when holding the <tt>ReentrantLock</tt> associated
 with this Condition. Failure to comply results in <CODE>IllegalMonitorStateException</CODE>.

 <p>In addition to implementing the <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks"><CODE>Condition</CODE></A> interface,
 this class defines methods <tt>hasWaiters</tt> and
 <tt>getWaitQueueLength</tt>, as well as some associated
 <tt>protected</tt> access methods, that may be useful for
 instrumentation and monitoring.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantLock.ConditionObject">Serialized Form</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#ReentrantLock.ConditionObject(java.util.concurrent.locks.ReentrantLock)">ReentrantLock.ConditionObject</A></B>(<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="class in java.util.concurrent.locks">ReentrantLock</A>&nbsp;lock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor for use by subclasses to create a
 ConditionObject associated with given lock.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#await()">await</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the current thread to wait until it is signalled or
 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#await(long, java.util.concurrent.TimeUnit)">await</A></B>(long&nbsp;time,
      <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="class in java.util.concurrent">TimeUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the current thread to wait until it is signalled or
 interrupted, or the specified waiting time elapses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#awaitNanos(long)">awaitNanos</A></B>(long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the current thread to wait until it is signalled or
 interrupted, or the specified waiting time elapses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#awaitUninterruptibly()">awaitUninterruptibly</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the current thread to wait until it is signalled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#awaitUntil(java.util.Date)">awaitUntil</A></B>(java.util.Date&nbsp;deadline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Causes the current thread to wait until it is signalled or
 interrupted, or the specified deadline elapses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="interface in java.util">Collection</A>&lt;<A HREF="../../../../java/lang/Thread.html" title="class in java.lang">Thread</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#getWaitingThreads()">getWaitingThreads</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a collection containing those threads that may be
 waiting on this Condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#getWaitQueueLength()">getWaitQueueLength</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an estimate of the number of threads are waiting on
 this condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#hasWaiters()">hasWaiters</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries whether any threads are waiting on this
 condition.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signal()">signal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wakes up one waiting thread.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signalAll()">signalAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wake up all waiting threads.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ReentrantLock.ConditionObject(java.util.concurrent.locks.ReentrantLock)"><!-- --></A><H3>
ReentrantLock.ConditionObject</H3>
<PRE>
protected <B>ReentrantLock.ConditionObject</B>(<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="class in java.util.concurrent.locks">ReentrantLock</A>&nbsp;lock)</PRE>
<DL>
<DD>Constructor for use by subclasses to create a
 ConditionObject associated with given lock.  (All other
 construction should use the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition()"><CODE>ReentrantLock.newCondition()</CODE></A> method.)
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>lock</CODE> - the lock for this condition
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if lock null</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="signal()"><!-- --></A><H3>
signal</H3>
<PRE>
public void <B>signal</B>()</PRE>
<DL>
<DD>Wakes up one waiting thread.

 <p>If any threads are waiting on this condition then one is
 selected for waking up.  This implementation always chooses
 to wake up the longest-waiting thread whose wait has not
 been interrupted or timed out.  That thread must then
 re-acquire the lock before it returns. The order in which
 it will do so is the same as that for threads initially
 acquiring the lock, which is in the default case not
 specified, but for <em>fair</em> locks favors those threads
 that have been waiting the longest. Note that an awakened
 thread can return, at the soonest, only after the current
 thread releases the lock associated with this Condition.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()">signal</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="signalAll()"><!-- --></A><H3>
signalAll</H3>
<PRE>
public void <B>signalAll</B>()</PRE>
<DL>
<DD>Wake up all waiting threads.

 <p>If any threads are waiting on this condition then they
 are all woken up. Each thread must re-acquire the lock
 before it returns.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()">signalAll</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUninterruptibly()"><!-- --></A><H3>
awaitUninterruptibly</H3>
<PRE>
public void <B>awaitUninterruptibly</B>()</PRE>
<DL>
<DD>Causes the current thread to wait until it is signalled.

 <p>The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread
 scheduling purposes and lies dormant until <em>one</em> of
 three things happens: 

 <ul>

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signal()"><CODE>signal()</CODE></A> method
 for this <tt>Condition</tt> and the current thread 
 has been waiting the longest of all waiting threads; or

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signalAll()"><CODE>signalAll()</CODE></A> method
 for this <tt>Condition</tt>; or

 <li>A &quot;<em>spurious wakeup</em>&quot; occurs

 </ul>

 <p>In all cases, before this method can return the current
 thread must re-acquire the lock associated with this
 condition. When the thread returns it is
 <em>guaranteed</em> to hold this lock.

 <p>If the current thread's interrupt status is set when it
 enters this method, or it is <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A> while waiting, it will continue to wait until
 signalled. When it finally returns from this method its
 <em>interrupted status</em> will still be set.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUninterruptibly()">awaitUninterruptibly</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="await()"><!-- --></A><H3>
await</H3>
<PRE>
public void <B>await</B>()
           throws java.lang.InterruptedException</PRE>
<DL>
<DD>Causes the current thread to wait until it is signalled or
 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>.

 <p>The lock associated with this <tt>Condition</tt> is
 atomically released and the current thread becomes disabled
 for thread scheduling purposes and lies dormant until
 <em>one</em> of four things happens:

 <ul>

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signal()"><CODE>signal()</CODE></A> method
 for this <tt>Condition</tt> and the current thread 
 has been waiting the longest of all waiting threads; or

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signalAll()"><CODE>signalAll()</CODE></A> method
 for this <tt>Condition</tt>; or

 <li>Some other thread <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupts</CODE></A>
 the current thread; or

 <li>A &quot;<em>spurious wakeup</em>&quot; occurs

 </ul>

 <p>In all cases, before this method can return the current
 thread must re-acquire the lock associated with this
 condition. When the thread returns it is
 <em>guaranteed</em> to hold this lock.

 <p>If the current thread has its interrupted status set on
 entry to this method or is <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A> while waiting, then <CODE>InterruptedException</CODE> is thrown and the current thread's
 interrupted status is cleared.  This implementation favors
 responding to an interrupt over normal method return in
 response to a signal.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#await()">await</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread is
 interrupted
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="awaitNanos(long)"><!-- --></A><H3>
awaitNanos</H3>
<PRE>
public long <B>awaitNanos</B>(long&nbsp;nanosTimeout)
                throws java.lang.InterruptedException</PRE>
<DL>
<DD>Causes the current thread to wait until it is signalled or
 interrupted, or the specified waiting time elapses.

 <p>The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread
 scheduling purposes and lies dormant until <em>one</em> of
 five things happens:

 <ul>

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signal()"><CODE>signal()</CODE></A> method
 for this <tt>Condition</tt> and the current thread 
 has been waiting the longest of all waiting threads; or

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signalAll()"><CODE>signalAll()</CODE></A> method
 for this <tt>Condition</tt>; or

 <li>Some other thread <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupts</CODE></A>
 the current thread; or

 <li>The specified waiting time elapses; or

 <li>A &quot;<em>spurious wakeup</em>&quot; occurs.

 </ul>

 <p>In all cases, before this method can return the current
 thread must re-acquire the lock associated with this
 condition. When the thread returns it is
 <em>guaranteed</em> to hold this lock.

 <p>If the current thread has its interrupted status set on
 entry to this method or is <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A> while waiting, then <CODE>InterruptedException</CODE> is thrown and the current thread's
 interrupted status is cleared.  This implementation favors
 responding to an interrupt over normal method return in
 response to a signal or timeout.

 <p>The method returns an estimate of the number of nanoseconds
 remaining to wait given the supplied <tt>nanosTimeout</tt>
 value upon return, or a value less than or equal to zero if it
 timed out. This value can be used to determine whether and how
 long to re-wait in cases where the wait returns but an awaited
 condition still does not hold.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitNanos(long)">awaitNanos</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nanosTimeout</CODE> - the maximum time to wait, in nanoseconds
<DT><B>Returns:</B><DD>A value less than or equal to zero if the wait has
 timed out; otherwise an estimate, that
 is strictly less than the <tt>nanosTimeout</tt> argument,
 of the time still remaining when this method returned.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread is
 interrupted.
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUntil(java.util.Date)"><!-- --></A><H3>
awaitUntil</H3>
<PRE>
public boolean <B>awaitUntil</B>(java.util.Date&nbsp;deadline)
                   throws java.lang.InterruptedException</PRE>
<DL>
<DD>Causes the current thread to wait until it is signalled or
 interrupted, or the specified deadline elapses.

 <p>The lock associated with this condition is atomically
 released and the current thread becomes disabled for thread
 scheduling purposes and lies dormant until <em>one</em> of
 five things happens:

 <ul>

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signal()"><CODE>signal()</CODE></A> method
 for this <tt>Condition</tt> and the current thread 
 has been waiting the longest of all waiting threads; or

 <li>Some other thread invokes the <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.ConditionObject.html#signalAll()"><CODE>signalAll()</CODE></A> method
 for this <tt>Condition</tt>; or

 <li>Some other thread <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupts</CODE></A>
 the current thread; or

 <li>The specified deadline elapses; or

 <li>A &quot;<em>spurious wakeup</em>&quot; occurs.

 </ul>

 <p>In all cases, before this method can return the current
 thread must re-acquire the lock associated with this
 condition. When the thread returns it is
 <em>guaranteed</em> to hold this lock.

 <p>If the current thread has its interrupted status set on
 entry to this method or is <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A> while waiting, then <CODE>InterruptedException</CODE> is thrown and the current thread's
 interrupted status is cleared.  This implementation favors
 responding to an interrupt over normal method return in
 response to a signal or timeout.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)">awaitUntil</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>deadline</CODE> - the absolute time to wait until
<DT><B>Returns:</B><DD><tt>false</tt> if the deadline has
 elapsed upon return, else <tt>true</tt>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread is interrupted
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread
<DD><CODE>java.lang.NullPointerException</CODE> - if deadline is null</DL>
</DD>
</DL>
<HR>

<A NAME="await(long, java.util.concurrent.TimeUnit)"><!-- --></A><H3>
await</H3>
<PRE>
public boolean <B>await</B>(long&nbsp;time,
                     <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="class in java.util.concurrent">TimeUnit</A>&nbsp;unit)
              throws java.lang.InterruptedException</PRE>
<DL>
<DD>Causes the current thread to wait until it is signalled or
 interrupted, or the specified waiting time elapses. This
 method is behaviorally equivalent to:<br>

 <pre>
   awaitNanos(unit.toNanos(time)) &gt; 0
 </pre>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html#await(long, java.util.concurrent.TimeUnit)">await</A></CODE> in interface <CODE><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="interface in java.util.concurrent.locks">Condition</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - the maximum time to wait<DD><CODE>unit</CODE> - the time unit of the <tt>time</tt> argument.
<DT><B>Returns:</B><DD><tt>false</tt> if the waiting time detectably
 elapsed before return from the method, else <tt>true</tt>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - if the current thread is
 interrupted
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread
<DD><CODE>java.lang.NullPointerException</CODE> - if unit is null</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters()"><!-- --></A><H3>
hasWaiters</H3>
<PRE>
public boolean <B>hasWaiters</B>()</PRE>
<DL>
<DD>Queries whether any threads are waiting on this
 condition. Note that because timeouts and interrupts may
 occur at any time, a <tt>true</tt> return does not
 guarantee that a future <tt>signal</tt> will awaken any
 threads.  This method is designed primarily for use in
 monitoring of the system state.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD><tt>true</tt> if there are any waiting threads.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength()"><!-- --></A><H3>
getWaitQueueLength</H3>
<PRE>
public int <B>getWaitQueueLength</B>()</PRE>
<DL>
<DD>Returns an estimate of the number of threads are waiting on
 this condition. Note that because timeouts and interrupts
 may occur at any time, the estimate serves only as an upper
 bound on the actual number of waiters.  This method is
 designed for use in monitoring of the system state, not for
 synchronization control.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the estimated number of waiting threads.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads()"><!-- --></A><H3>
getWaitingThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="interface in java.util">Collection</A>&lt;<A HREF="../../../../java/lang/Thread.html" title="class in java.lang">Thread</A>&gt; <B>getWaitingThreads</B>()</PRE>
<DL>
<DD>Returns a collection containing those threads that may be
 waiting on this Condition.  Because the actual set of
 threads may change dynamically while constructing this
 result, the returned collection is only a best-effort
 estimate. The elements of the returned collection are in no
 particular order.  This method is designed to facilitate
 construction of subclasses that provide more extensive
 condition monitoring facilities.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the collection of threads
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalMonitorStateException</CODE> - if the lock associated
 with this Condition is not held by the current thread</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="class in java.util.concurrent.locks"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="class in java.util.concurrent.locks"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ReentrantLock.ConditionObject.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
